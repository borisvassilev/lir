This program can be used as a filter to noweb.
It deduces the programming language of code chunks based on the names of the chunks.
This is a table of known extensions.
<<Ext-Lang>>=
{"pl", "prolog"},
{"sh", "bash"},
{"bash", "bash"},
{"cpp", "cpp"},
{"R", "R"},
{"awk", "awk"},
{"sed", "sed"},
{"css", "css"}
@

<<langs.cpp>>=
<<Includes (`langs`)>>
<<Function definitions (`langs`)>>

int main()
{
    <<Variable definitions (`langs`)>>

out:
{   
    <<`Out` transitions>>
    goto out;
}

code:
{
    <<`Code` transitions>>
    goto code;
}

content:
{
    <<`Content` transitions>>

    std::string un;
    if (string_prefix_rest(line, {"@use "}, un))
        uses[name].insert(un);

    goto content;
}

end:
{
    <<Propagate language to uses>>
    <<Output all lines with `@language` after `@defn`>>
    return 0;
}

error:
    return 1;
}
@

<<`Out` transitions>>=
if (!std::getline(std::cin, line)) goto end;
lines.push_back(line);

if (string_prefix(line, {"@begin code"})) goto code;
@

<<`Code` transitions>>=
if (!std::getline(std::cin, line)) goto error;
lines.push_back(line);

if (string_prefix_rest(line, {"@defn "}, name)) {
    <<Process code chunk name>>
    goto content;
}
<<Process code chunk name>>=
uses.insert({name, {}}); 
std::string cl;
if (name_dict_lang(name, langs, cl)) {
    chunk_lang.insert({name, cl});
    pending.push(name);
}
@

<<`Content` transitions>>=
if (!std::getline(std::cin, line)) goto error;
lines.push_back(line);

if (string_prefix(line, {"@end code"})) goto out;
@

<<Variable definitions (`langs`)>>=
std::vector<std::string> lines{};
std::map<std::string, std::set<std::string>> uses{};
std::map<std::string, std::string> chunk_lang{};
std::queue<std::string> pending{};
const std::map<std::string, std::string> langs{<<Ext-Lang>>};

std::string line;
std::string name;
@

This uses a queue to do a width-first traversal of the use-tree.
Initially, the queue is filled with the 
<<Propagate language to uses>>=
while (!pending.empty()) {
    std::string next = pending.front();
    pending.pop();

    for (auto c : uses[next]) {
        auto x = chunk_lang.find(c);
        if (x == chunk_lang.cend()) {
            chunk_lang.insert({c, chunk_lang[next]});
            pending.push(c);
        }
    }
}
@

<<Output all lines with `@language` after `@defn`>>=
for (auto l : lines) {
    std::cout << l << '\n';

    if (string_prefix_rest(l, {"@defn "}, name)) {
        auto x = chunk_lang.find(name);
        if (x != chunk_lang.cend())
            std::cout << "@language " << x->second << '\n';
        else
            std::cout << "@language txt\n";
    }
}
@



<<Includes (`langs`)>>=
#include <iostream>
#include <vector>
#include <map>
#include <set>
#include <string>
#include <queue>
@

Predicate that checks if a string has a prefix.
<<Function definitions (`langs`)>>=
bool
string_prefix(const std::string& s, const std::string& t)
{
    if (0 == s.compare(0, t.length(), t)) return true;
    return false;
}
@

Predicate that checks if a string has a prefix and returns the rest.
<<Function definitions (`langs`)>>=
bool
string_prefix_rest(const std::string& s, const std::string& t,
                   std::string& rest)
{
    if (string_prefix(s, t)) {
        rest = s.substr(t.length());
        return true;
    }
    return false;
}
@

A predicate that checks if a string ends with an extension available in a dictionary and returns the corresponding language.
<<Function definitions (`langs`)>>=
bool
name_dict_lang(const std::string& n,
               const std::map<std::string, std::string>& d,
               std::string& l)
{
    size_t x = n.find_last_of('.');
    if (x == std::string::npos) return false;

    ++x;
    auto ext_lang = d.find(n.substr(x));
    if (ext_lang == d.cend()) return false;

    l = ext_lang->second;
    return true;
}
@
